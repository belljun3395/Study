### 컬렉션 프레임웍

---

컬렉션 프레임웍이란, '데이터 군을 저장하는 클래스들을 표준화한 설계'를 뜻한다.

컬렉션은 다수의 데이터, 즉 데이터 그룹을, 프레임웍은 표준화된 프로그래밍 방식을 의미한다.



#### 컬렉션 프레임웍의 핵심 인터페이스

---

![img](https://postfiles.pstatic.net/MjAxNzA0MjNfNjUg/MDAxNDkyODgwNzA3MTg4.9dc_43OswT4Aa3gHKtd-3iDHTvQSm1ZefGekVD81yogg.cpP211YGWbinrVlCK6co_02iIn3hrrwevvdX4lOMejIg.PNG.heartflow89/image.png?type=w773)



인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통부분이 있어서, 공통된 부분을 다시 뽑아 Collection 인터페이스를 정의할 수 있었지만 Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했다.



| 인터페이스 | 특징                                                         |
| ---------- | ------------------------------------------------------------ |
| List       | 순서가 있는 데이터 집합, 데이터의 중복을 허용한다.           |
| Set        | 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다. |
| Map        | 키와 값의 쌍으로 이루어진 데이터의 집합<br />순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다. |



컬렉션 프레임웍의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스의 이름에 포함되어있어서 이름만으로도 클래스의 특징을 쉽게 알 수 있다.

하지만  Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬랙션 프레임웍이 만들어지기 이전부터 존재하여 컬렉션 프레임웍의 명명법을 따르지 않는다.



##### Collection 인터페이스

---

Collection 인터페이스는 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 메서드를 정의하고 있다.



##### List 인터페이스

---

List 인터페이스는 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다.



##### Set 인터페이스

---

Set  인터페이스는 중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용된다.



##### Map 인터페이스

---

Map 인터페이스는 키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용된다.

키는 중복될 수 없지만 값은 중복을 허용한다.

 

Map 인터페이스의 메서드중 values()는 반환타입이 Collection이고, keySet()은 반환타입이 Set인 것에 주목하자.

Map 인터페이스에서 값은 중복을 허용하기 때문에 Collection 타입으로 반환하고, 키는 중복을 허용하지 않기 때문에 Set 타입으로 반환한다.



##### Map.Entry 인터페이스

---

Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스이다.

내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스를 정의하는 것이 가능하다.

Map에 저장되는 key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았다.



```java
public interface Map<K, V> {
    ...
    interface Entry {
        Object getkey();
        Object getValue();
        Object setValue(Object value);
        boolean equals(Object o);
        int hashCode();
        ...
    }
    ...
}
```



#### ArrayList

---

ArrayList는 List 인터페이스를 구현한 **컬렉션 클래스**로 데이터 저장순서가 유지되고 중복을 허용한다.

ArrayList는 기존의 Vector를 개선한 것으로 Vector와 구현원리와 기능적인 측면에서 동일하다고 할 수 있다.



ArrayList는 Object 배열을 이용해서 데이터를 순차적으로 저장한다.



```java
import java.util.*;

class VectorEx1 {
	public static void main(String[] args) {
		Vector v = new Vector(5);	// 용량(capacity)이 5인 Vector를 생성한다.
		v.add("1");
		v.add("2");
		v.add("3");
		print(v);

		v.trimToSize();	// 빈 공간을 없앤다.(용량과 크기가 같아진다.)
		System.out.println("=== After trimToSize() ===");
		print(v);

		v.ensureCapacity(6);
		System.out.println("=== After ensureCapacity(6) ===");
		print(v);

		v.setSize(7);
		System.out.println("=== After setSize(7) ===");
		print(v);
		
		v.clear();
		System.out.println("=== After clear() ===");
		print(v);
	}

	public static void print(Vector v) {
		System.out.println(v);
		System.out.println("size :" + v.size());
		System.out.println("capacity :" + v.capacity());
	}
}

```



> [1, 2, 3]
> size :3
> capacity :5
> === After trimToSize() ===
> [1, 2, 3]
> size :3
> capacity :3
> === After ensureCapacity(6) ===
> [1, 2, 3]
> size :3
> capacity :6
> === After setSize(7) ===
> [1, 2, 3, null, null, null, null]
> size :7
> capacity :12
> === After clear() ===
> []
> size :0
> capacity :12



이는 Vector의 용량과 크기에 관한 예제이다.

위에서 주목할 점은 Vector의 용량이 바뀌면 기존의 인스턴스를 다시 사용하는 것이 아니라 새로운 인스턴스를 생성한다는 점이다.



그렇기에 ArrayList나 Vector 같이 배열을 이요한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야하기 때문에 상당히 효율이 떨어지는 단점을 지니고 있다.

그래서 처음에 인스턴스를 생성할 때, 저장할 데이터의 개수를 잘 고려하여 충분한 용량의 인스턴스를 생성하는 것이 좋다.



 다음의 코드는 Vector 클래스의 실제코드를 바탕으로 재구성한 것이다.

이를 통해 위의 

" Vector의 용량이 바뀌면 기존의 인스턴스를 다시 사용하는 것이 아니라 새로운 인스턴스를 생성한다는 점이다."

에 관한 의문점을 해결 할 수 있다.

```java
import java.util.*;

public class MyVector implements List {
	Object[] data = null;	// 객체를 담기 위한 객체배열을 선언한다.
	int capacity = 0;		// 용량
	int size = 0;			// 크기

	public MyVector(int capacity) {
		if (capacity < 0)
		   throw new IllegalArgumentException("유효하지 않은 값입니다. :"+ capacity);

		this.capacity = capacity;
		data = new Object[capacity];		
	}

	public MyVector() {
		this(10);		// 크기를 지정하지 않으면 크기를 10으로 한다.
	}

    // 최소한의 저장공간(capacity)를 확보하는 메서드
	public void ensureCapacity(int minCapacity) {
		if (minCapacity - data.length > 0)
			setCapacity(minCapacity);
	}

	public boolean add(Object obj) {
		// 새로운 객체를 저장하기 전에 저장할 공간을 확보한다.
		ensureCapacity(size+1);
		data[size++] = obj; 
		return true;
	}

	public Object get(int index) {
		if(index < 0 || index >= size) 
			throw new IndexOutOfBoundsException("범위를 벗어났습니다.");

		return data[index];
	}

	public Object remove(int index) { 
		Object oldObj = null;

		if(index < 0 || index >= size) 
			throw new IndexOutOfBoundsException("범위를 벗어났습니다.");

		oldObj = data[index];

		// 삭제하고자 하는 객체가 마지막 객체가 아니라면, 배열복사를 통해 빈자리를 채워줘야 한다.
		if(index != size-1) {
			System.arraycopy(data, index+1, data, index, size-index-1);
		}

        // 마지막 데이터를 null로 한다. 배열은 0 부터 시작하므로 마지막 요소는 index가 size-1이다.
		data[size-1] = null;	
		size--;
		return oldObj;
	}

	public boolean remove(Object obj) {
		for(int i=0; i< size; i++) {
			if(obj.equals(data[i])) {
				remove(i);
				return true;
			}
		}
		return false;
	}

	public void trimToSize() {
		setCapacity(size);
	}

	private void setCapacity(int capacity) {
		if(this.capacity==capacity) return; // 크기가 같으면 변경하지 않는다.

		Object[] tmp = new Object[capacity];
		System.arraycopy(data,0, tmp, 0, size);
		data = tmp;
		this.capacity = capacity;
	}

	public void clear(){ 
		for (int i = 0; i < size; i++)
			data[i] = null;
		size = 0;
	}

	public Object[] toArray(){ 
		Object[] result = new Object[size];
		System.arraycopy(data, 0, result, 0, size);

		return result;
	}

	public boolean isEmpty() { return size==0;}
	public int capacity() { return capacity; }
	public int size() { return size; }
/****************************************/
/*       List인터페이스로부터 상속받은 메서드들          */
/****************************************/
//  public int size();
//  public boolean isEmpty();
	public boolean contains(Object o){ return false;}
	public Iterator iterator(){ return null; }
//	public Object[] toArray();
	public Object[] toArray(Object a[]){ return null;}
//  public boolean add(Object o);
//  public boolean remove(Object o);
	public boolean containsAll(Collection c){ return false; }
	public boolean addAll(Collection c){ return false; }
	public boolean addAll(int index, Collection c){ return false; }
	public boolean removeAll(Collection c){ return false; }
	public boolean retainAll(Collection c){ return false; }
//	public void clear();
	public boolean equals(Object o){ return false; }
//	public int hashCode();
//  public Object get(int index);
	public Object set(int index, Object element){ return null;}
	public void add(int index, Object element){}
//  public Object remove(int index);
	public int indexOf(Object o){ return -1;}
	public int lastIndexOf(Object o){ return -1;}
	public ListIterator listIterator(){ return null; }
	public ListIterator listIterator(int index){ return null; }
	public List subList(int fromIndex, int toIndex){ return null; }

//	default void sort(Comparator c) { /* 내용생략 */ }                     // JDK1.8부터
//	default Spliterator spliterator() { /* 내용생략 */ }                  // JDK1.8부터
//	default void replaceAll(UnaryOperator operator){/* 내용생략 */} //JDK1.8부터
}

```

ensureCapacity() 그리고 trimToSize()는 setCapacity()를 사용하기에 기존의 인스턴스를 사용하는 것이 아닌 새로운 인스턴스를 사용하게 되는 것이다.



#### LinkedList

---

