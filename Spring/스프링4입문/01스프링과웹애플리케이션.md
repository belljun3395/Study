## 01스프링과웹애플리케이션

---



### 스프링과 웹 애플리케이션

---

규모가 큰 애플리케이션을 자바로 만들 때 필요한 프레임워크이다.

#### 웹 애플리케이션이란?

---

웹 시스템의 기본적인 구조는 간단하다.

정적 콘텐츠는 클라이언트 머신의 웹 브라우저가 네트워크에 있는 웹 서버로부터 요청한 HTML을 읽어와 표시하면 된다.

동적 콘텐츠의 경우는 웹 서버에서 애플리케이션 서버에 처리를 요청하고 대부분은 RDB에서 데이터를 읽어오거나 가공하고 그 처리 결과를 웹 서버에서 받아 웹 브라우저에 표시한다.



현재는 Ajax로 웹 브라우저에 풍부한 화면을 구현할 수 있다.

RDB 대신 KVS(Key Value Store)를 사용하고  클라이언트가 스마트폰인 경우도 많다.

서비스의 실체가 클라우드 안에 숨어 있어 단순히 인터넷상의 서비스로 존재할 때도 있지만 기본적인 동작은 앞서 설명한 것과 같다.



이상이 일반적인 웹 시스템에 관한 이야기이다.



이제 이 책에서 다룰 웹 애플리케이션에 대해 알아보자.

이 애플리케이션은 다음과 같은 동작의 반복이다.

1. 웹 브라우저에서 버튼 클릭
2. 버튼에 대응한 비즈니스 로직이 RDB의 데이터를 이용해서 처리 진행
3. 처리 결과를 전송
4. 웹 브라우저에 표시



웹 애플리케이션에 주의해야 할 점은 처리 결과를 전송한 후 접속이 끊어져버리는 것으로 상태를 저장할 수 없다는 것이다.





#### JSP, Servlet의 등장

---

우선 CGI(Common Gateway Interface)에 대해서 알아보자.

이는 HTTP의 요청으로 실행되는 프로그램으로 웹 브라우저의 요청을 받아 CGI가 해당 프로그램을 실행함으로써 같은 요청의 처리 결과로 다른 콘텐츠를 반환할 수 있게 되었다.



하지만 GCI에는 몇 가지 문제가 있다.

가장 큰 문제는 처리를 요청할 때마다 프로그램이 실행되는 점과 세션 관리가 없다는 점이다.

이러한 문제는 처리 요청이 많아지면 성능 저하나 트랜잭션 관리의 어려움을 초래했다.



그래서 JSP, Servlet이 등장했다.

이들은 멀티 스레드로 실행되고, 실행 기반인 웹 컨테이너는 개발자가 세션 관리를 의식하지 않을 수 있도록 세션을 관리해준다.

또 JSP로 페이지를 생성하고 비즈니스 로직을 Servlet으로 처리하는 아키텍처도 큰 장점이다.



#### 스프링의 등장

---

스프링으로 대표되는 고성능 DIxAOP 컨테이너는 EJB의 장점인 선언적 트랜잭션 관리를 POJO로 구현할 수 있다.

데이터베이스 접근은 다양한 O/R 매핑 프레임워크를 이용한다.

EJB 컨테이너 대신 DIxAOP 컨테이너를 이용하는 가장 큰 이유는 DIxAOP 컨테이너에 실을 수 있는 오브젝트가 POJO라고 부르는 일반 자바 오브젝트이기 때문이다.

DIxAOP 컨테이너로 관리되는 POJO는 DI 컨테이너에 의존하지 않는다는 특징 덕분에 단위 테스트를 쉽게 수행할 수 있다.



#### 스프링의 현재

---

현재 사실상 스프링이 Java/Java EE의 표준 프레임워크이다.



### 애플리케이션 아키텍처

---



#### 애플리케이션 아키텍처의 필요성

---

애플리케이션 아키텍처는 일반적으로 애플리케이션 전체의 구조, 공통된 방식이라고 정의할 수 있다.

다시 말해, 시스템의 애플리케이션이 공통으로 이용할 수 있는 사용자 인터페이스 구조나 데이터베이스 접근 방식 등 시스템의 기반이 되는 부분을 말한다.

그러나 아키텍처는 다양하게 정의할 수 있다.



##### 웹 애플리케이션 개발의 목표

---

첫째는 유스 케이스등으로 표현되는 기능 요구나 응답 시간 등을 규정한 비기능적 요구를 포함한 사용자의 요구를 만족한다는 목표이다.



둘째는 비동기 요건이나 제약에 포함되는 개발 기간 엄수나 변경, 기능 추가의 용이성, 테스트의 용이성 등 개발자나 운영자를 위한 목표이다.



구체적으로 다음과 같은 구조로 이루어진 애플리케이션 아키텍처의 실현을 목표로 한다.

- 개발 효율
  - 의도를 파악하기 쉽고 이해하기 쉬운 구조
  - 테스트하기 쉬운 구조
- 유연성
  - 변경하기 쉽고 기능을 추가하기 쉬운 구조
  - 미래의 환경 변화에 대응할 수 있는 견고한 구조



##### 개발 효율성과 애플리케이션 아키텍처의 필요성

---

애플리케이션 아키텍처는 이해하기 쉽고 간단히 사용할 수 있어야 한다.

또 테스트는 간단하게 실행할 수 있어야 한다.



##### 웹 애플리케이션의 생명 주기와 애플리케이션 아키텍처의 필요성

---

애플리케이션 아키텍처의 목표에 변경이나 기능 추가의 용이성, 미래의 환경 변화에 대응할 수 있는 유연성은 웹 애플리케이션에 대한 사용자의 요구가 변하기 쉽기 때문이다.



웹 애플리케이션의 생명 주기는 웹 애플리케이션 릴리스, 요구 변화, 변경 및 기능 추가라는 상태를 웹 애플리케이션이 폐기될 때 까지 반복한다.

이처럼 폐기될 때까지 계속 변경되는 상태를 가리켜 웹 애플리케이션의 완성은 웹 애플리케이션이 폐기될 때라고 말하기도 한다.



##### 애플리케이션 아키텍처는 자유로운 발상으로

---

사용자의 요구에 따라서 변경이나 확장의 용이성을 무시하고 애플리케이션 아키텍처 등을 고려하지 않은 채 JSP로 데이터베이스에 직접 접근해도 좋다.



#### 티어와 레이어

---

웹 애플리케이션의 아키텍처는 크게 티어라고 하는 물리층과 레이어라고 하는 논리층으로 나뉜다.



티어는 클라이언트 층, 중간층, EIS 층의 3개의 층이 기본이다.

기본적으로 웹 애플리케이션에 고려할 것은 중간층이지만, 현재 웹 애플리케이션에서는 클라이언트 층이 데스크톱 컴퓨터이고 중간층에 있는 웹 애플리케이션에서 웹 브라우저에 HTML을 보내는 것이라는 설명만으로는 충분하지 않다.



레이어는 클라이언트 층에도 일부 있지만, 기본적으로는 중간층에 있는 웹 애플리케이션을 논리적으로 분류한 것이다.



레이어는 원래 아키텍처 패턴 중에 하나이며, 서로 인접한 레이어끼리만 단방향 액세스를 할 수 있다.

일반적인 레이어는 다음 3개의 층으로 나누고 각각 다른 역활을 부여한다.



- 프레젠테이션 층 
  사용자 인터페이스와 컨트롤러를 제공한다. 이 층에는 클래스 이름에 Controller나 Action이 붙은 클래스가 배치된다.
- 비즈니스 로직 층
  비즈니스 로직을 제공한다. 이 층에는 이름 끝에 Service가 붙은 유스 케이스를 제어하는 클래스나 회사나 종업원, 주문 등 업무 대상의 이름이 붙은 클래스가 배치된다.
- 데이터 액세스 층
  데이터베이스 액세스를 추상화한다. 이 층에는 클래스 이름 끝에 Dao가 붙은 클래스가 배치된다.



> **컨트롤러 :**
>
> 화면 전환이나 화면에서 버튼을 눌렀을 때의 동작 제어 또는 세션 관리 등을 함
>
> **서비스 :**
>
> 유스 케이스로 표현되는 특정 업무나 특정 부서 처리의 통합. 
>
> 트랜잭션의 기점. 
>
> 일반적으로는 stateless 클래스
>
> **도메인 :**
>
> 서비스로부터 비즈니스를 실행하는 데 반드시 사용하는 고객과 주문 같은 클래스의 집합.
>
> 자신이 무엇인지 나타내는 값과 그 값을 이용한 처리를 실현함 



현재 웹 애플리케이션 레이어라고 부르는 것에는 인접하는 레이어에 대한 단방향 액세스뿐만 아니라, 상호 의존을 하는 것도 있다.

이러한 것은 레이어가 아니다.

단지 화면 쪽이나 데이터베이스 쪽에 관련된 내용이다.

이러한 현상을 발견하면 리팩터링하는 것이 좋다.



#### 오목형 레이어

---

웹 애플리케이션의 레이어는 크게 비즈니스와 관련된 부분과 비즈니스 로직의 결과를 어떻게 표현할지 구현하는 두 부분으로 나눌 수 있다.

비즈니스 로직의 결과를 어떻게 다룰지 구현하는 기술이 비즈니스 로직에 영향을 미치지 않는 것이 좋은 설계이다.



오목형 레이어는 다음과 같다.

![Check out the image](https://doorisopen.github.io/assets/images/2019/Spring/spring_basic_05.JPG)



오목형 레이어에서 중요한 점은 프리젠터이션 층에서의 변화가 비즈니스 층에 영향을 미치지 않는다는 점이다.

즉, 비즈니스 층이야말로 시스템의 핵심이나 기반이므로 표시 메커니즘이나 영속화 메커니즘이 바뀌어도 영향을 받지 않게 만드는 것이 중요하다.



비즈니스 로직 층을 다른 층의 변경과 분리하려면 레이어를 형식으로만 분류할 것이 아니라 레이어의 결합 부분에 인터페이스르 도입한 약한 결합 설계나 구현을 고려해야 한다.



### 프레젠테이션 층의 역활

---

프레젠테이션 층의 주된 역활은 사용자 인터페이스와 컨트롤러를 제공하는 것이다.

사용자 인터페이스란 사용자가 직접 조작하는 화면이나 장표를 말한다.

컨트롤러는 사용자 인터페이스를 통해 사용자의 입력을 받아 적절한 비즈니스 로직을 호출하고, 그 결과를 사용자 인터페이스로 반환하는 작업을 한다.

컨트롤러의 또 한 가지 중요한 작업은 웹 애플리케이션의 상태를 저장해 이용하는 데이터를 관리하는 것이다.

컨트롤러는 일반적으로 MVC2라고 불리는 JSP 모델의 컨트롤러로 알려져 있다.



#### MVC2란?

---

예전 J2EE의 MVC2는 스몰토크에서 확립된 MVC 패턴을 참고한 것으로, Model 부분에 JavaBeans(EJB), View 부분에 JSP, Controller 부분에 Servlet을 사용한다.



![img](https://t1.daumcdn.net/cfile/tistory/2311AC46521AF3E80A)





### 비즈니스 로직 층의 역활

---

비즈니스 로직 층은 서비스나 도메인 같은 비즈니스 로직을 구현하는 웹 애플리케이션의 중심이다.



비즈니스 로직 층은 유스 케이스로 표현되는 특정 업무나 특정 부서 처리의 통합인 서비스 및 도메인으로 구성된다.

도메인은 서비스에서 시작되는 비즈니스 실행에서 필요한 고객이나 주문 등의 처리를 구현하는 클래스의 집합이다.

이 서비스와 도메인은 각각 비즈니스  층에 만들어진 서비스 패키지의 클래스와 도메인 패키지의 클래스로 구현한다.



그런데 개발할 때나 운영할 때나 웹 애플리케이션의 기능 추가와 변경은 주로 비즈니스 로직 층의 로직 변경이다.

다시 말해 아키텍처가 유연한 웹 애플리케이션ㅇ르 만들기 위해서는 로직 층을 잘 만드는 것이 매우 중요하다.



#### 비즈니스 로직 층의 패턴

---

비즈니스 로직 층을 설계할 때는 어느 클래스에 할당할지가 중요하다.



##### 트랜잭션 스크립트

---

일반적인 지침으로는 데이터베이스의 내용을 표시/변경하기만 하는 업무 처리, 즉 비즈니스 로직이 적은 단순 입출력 애플리케이션일 때는 로직을 전부 서비스 클래스에 포함시키는 편이 좋다.

이는 로직이 없는 도메인 클래스는 객체 지향이 아니라고 비판을 받을 수도 있다.



##### 도메인 모델

---

대규모 개발의 경우 기본적으로 트랜잭션 스크립트와 같은 로직 주도 설계로 만드는 경우가 많지만, 최근 시스템 개발은 비즈니스 로직이 복잡한 것도 많다.

또한 웹 애플리케이션의 생명 주기를 고려해 상속 등 객체 지향의 이점을 살린 변경이나 확장의 용이성이 필요할 때도 많다.

그럴 때 트랜잭션 스크립트 비즈니스 로직을 만들면 비즈니스 로직이 복잡해져 마치 구조화 언어로 만든 것처럼 크고 복잡한 비즈니스 로직이 된다.

이를 방지하려면 도메인 패키지의 클래스에 도메인 로직을 두는 도메인 모델로 비즈니스 로직 층을 만드는 것이 좋다.



그리고 주의할 점은 스프링이 중심이 되는 DIxAOP 컨테이너는 도메인 모델의 구축이나 관리에 별로 도움이 되지 않는다는 점이다.

도메인 모델은 로직을 가진 메서드뿐만 아니라 속성, 즉 값을 가진 인스턴스로서 생성되지만, 값을 가진 인스턴스는 RDB에서 읽어와서 RDB와의 통신으로 관리된다.

다시 말해, 도메인의 생성과 관리는 DIxAOP 컨테이너가 아닌 데이터 액세스 층의 구조에 의존한다.

바꾸어 말하면, 스프링은 도메인 모델을 제외한 모든 것에 대응할 수 있는 프레임워크이다.



#### 트랜잭션 관리

---

트랜잭션이란 간단히 말해 처리 단위이다.

트랙잭션에는 지켜야할 ACID라는 특성이 있다.

이 중에서 애플리케이션 아키텍처로 신경을 써야 하는 것은 원자성과 독립성이다.



시스템을 구축할 때는 원자성의 범위를 정해야한다.

모든 처리가 실행됐는지, 실행되지 않았는지 처리 단위를 정하는 것이다.

일반적으로 트랜잭션은 메서드에 들어가면서 트랜잭션 시작, 그 메서드를 빠져나오면서 트랜잭션 커밋처럼 결정한다.

트렌잭션 대상이 되는 메서드에서 호출된 메서드는 모두 트랜잭션의 대상이 된다.



그러므로 트랜잭션 대상의 메서드가 모든 층에 흩어져 있으며 관리하기가 어렵다.

따라서 관리하기 쉽게 일정한 규칙으로 트랜잭션의 시작과 종료가 이루어지는 메서드를 정해야한다.

이러한 규칙으로 만들어진 트랜잭션의 시작과 종료는 논리적으로 레이어상의 선으로 나타나는데, 이것이 트랜잭션의 경계선이다.



트랜잭션의 경계선은 프레젠테이션 층과 비즈니스 로직 층 사이에 그어지는 것이 일반적이다.

프레젠테이션 층의 클래스에서 서비스 클래스의 메서드를 호출하면 트랜잭션이 시작되고, 서비스 클래스의 메서드가 종료되고 프레젠테이션 층의 클래스로 되돌아갈 때 트랜잭션이 종료된다.



중요한 것은 트랜잭션의 경계를 만들기 위한 트랜잭션 구현을 어떻게 설계할 것인지이다.



트랜잭션의 시작과 커밋, 롤백과 같은 RDB에 대한 트랜잭션 관리 소스 코드로 명시하는 것을 명시적 트랜잭션이라 하고, 소스 코드로 기술하지 않고 정의 파일 등으로 선언해 프레임워크 등에서 제공되는 트랜잭션 처리에 트랜잭션 관리를 시키는 것을 선언적 트랜잭션이라 한다.



##### 선언적 트랜잭션

---

선언적 트랜잭션을 이용하면 비즈니스 로직 층에 포함되는 컴포넌트를 자유롭게 조합할 수 있고, 또한 개발자도 트랜잭션을 의식하지 않고 로직에 전념할 수 있다.

애플리케이션 아키텍처를 유연하게 하려면 선언적 애플리케이션 아키텍처를 적극적으로 선택하는 것이 좋다.

선언적 트랜잭션을 이용할 때, 트랜잭션의 경계가 되는 것은 서비스 클래스의 메서드이다.

서비스 클래스의 메서드가 호출되면 트랜잭션이 시작되고 메서드가 종료되면 트랜잭션이 커밋된다.



##### 명시적 트랜잭션

---

만약 명시적 트랜잭션을 구현해야 한다면 프레젠테이션 층의 컨트롤러로 트랜잭션을 구현하고 비즈니스 층에 포함되는 컴포넌트는 트랜잭션으로부터 자유롭게 해야 한다.

그렇게 해야 트랜잭션 중첩에 신경 쓰지 않고 비즈니스 로직 층에 있는 컴포넌트를 자유롭게 조합할 수 있다.



또한, 프레젠테이션 층에서 트랜잭션을 구현할 때는 트랜잭션 관리가 한 곳에서 이루어지게 해야 한다.



#### 데이터 액세스 층의 역활

---



##### O/R 매핑

---

일반적으로 O에서 R의 O/R 매핑은 객체 지향 분석으로 엔티티를 추출해, 그 엔티티를 바탕으로 설계 단계에서 테이블을 작성한다.

기본적으로 테이블의 한 레코드가 한 오브젝트에 대응한다.

객체 지향으로 분석, 설계하면 일반적으로 이러한 O/R 매핑이 된다.



마찬가지로 R에서 O/R 매핑은 시스템의 데이터 분석을 DOA  등에서 처리해 테이블을 작성할 경우나 시스템 개발 이전에 테이블이 이미 존재할 경우에 사용한다.



또한, 주로 참조용 웹 애플리케이션이나 단순 입출력 애플리케이션일 때는 화면에 표시할 데이터를 모아 한 오브젝트로 만드는 편이 효율적이므로, O/R 매핑을 피하고 R/O 매핑을 일부러 선택하는 것도 고려할 수 있다.



##### DB 액세스 프레임워크의 종류

---

DB 액세스 프레임워크로 흔히 알려진 것은 ORM이다.

ORM은 XML 등으로 기술된 매핑 파일로, 오브젝트와 테이블을 매핑한다.

매핑 파일 작성은 손이 많이 가지만 개발자가 SQL 문을 작성하지 않아도 된다는 특징이 있다.



ORM의 대표적인 프레임워크가 하이버네이트이다.



##### 데이터 액세스 층의 설계 지침

---

O/R 매핑은 ORM이라고 일컫는 하이버네이트 등을 이용한다.

R/O 매핑으로도 테이블 구조가 복잡하면 스프링 JDBC처럼 직접 SQL을 이용하는 방법도 생각해볼 수 있다.

하이버네이트 같은 프레임워크를 이용하면 다음과 같은 '설계 시 고려해야 하는 내용'이 포함돼 있어어서 별도로 설계하지 않아도 된다.



###### 커넥션 풀링을 이용한다.



###### RDB가 바뀌어도 구현에 영향을 미치지 않게 한다.



###### 이용하는 RDB에 의존적인 SQL 문을 기술하지 않는다.



DB 액세스 프레임워크가 포함되므로 데이터 액세스 층에서는 설계할 곳이 거의 없다.

데이터 액세스 층의 인터페이스만 설계하면 된다.

즉, 테이블과 도메인의 관계, 다시 말해 O/R 매핑 부분만 설계한다.

테이블과 도메인 설계가 끝나면 그 시스템의 특징과 필요한 성능을 얻을 수 있는 DB 액세스 프레임워크를 선택하면 된다.



###### 비즈니스 로직 층과 데이터 액세스 층의 분리

일반적인 설계로는 트랜잭션 관리를 위해 비즈니스 로직 층에서 java.sql.Connection을 취득해서 데이터 액세스 층에 전달하는 인터페이스가 된다.

이래서는 아무리 인터페이스 기바능로 하더라도 데이터 액세스 층이 비즈니스 로직 층에 의존하게 된다.

인터페이스로부터 커넥션을 분리하는 방법으로는 ThreadLocal을 이용한 패턴 사용 등을 생각할 수 있다.



##### 부품화

---

부품이 큰 쪽은 티어나 레이어가 되고, 그보다 작은 부품은 패키지나 컴포넌트가 된다.

그리고 부품끼리는 인터페이스로 연결된다.

정리하면 이 모든 것이 부품화라고 할 수 있다.



여기서 중요한 점은, 부품화는 인터페이스가 중요하다는 것이다.



부품화의 2가지 중요점을 알아보자.



첫째는 2개의 부품이 있을 때, 인터페이스를 어느 쪽이 가져야 하는지 결정해야 한다.

전자 제품을 보면 알겠지만 더 중요한 부품이 인터페이스를 가진다.



둘째는 어느 정도까지 부품화를 해야 하는가이다.

다르게 말하면 부품 하나의 크기를 어떻게 잡아야 할까이다.

여기에 절대적인 기준은 없으며 부품화할 필요가 있는 만큼 부품화한다가 정답이다.



#### 웹 애플리케이션이 안고 있는 문제

---



##### EJB의 문제

---

AOP 프레임워크가 됐으므로 이제 EJB와 비교해 스프링의 우위를 증명하는 방법은 성립하지 않는다.

과거에 EJB라는 중량 컨테이너의 안티테제로서 경량 컨테이너를 자처하고 등장한 스프링이 현재는 오히려 비교 대상이 Java EE가 됐을 정도로 스프링은 거대해졌다.



##### 오브젝트의 생명주기

---

웹 애플리케이션의 프레젠테이션 부분에는 서블릿을 컨트롤러로 한 MVC2 모델을 채용하는 것이 일반적이다.

컨트롤러를 구현하는 서블릿은 View에 액세스하는 사용자 수가 증가할 때마다 인스턴스화에 의한 가비지 컬렉션의 성능 저하나 메모리 압박을 방지하도록 멀티스레드로 동작시키고 있다.

하지만 컨트롤러에서 호출되는 서비스 로직의 오브젝트를 매번 인스턴스화하게 설계/구현해 버리면, View에 액세스하는 사용자 수가 늘어났을 때 인스턴스가 증가해 가비지 컬렉션의 성능이 떨어지거나 메모리 압박이 일어날 우려가 있다.

이를 방지하려면 서비스 로직의 오브젝트는 싱글턴으로 해야 하지만, 오브젝트를 싱글턴으로 하려면 구현을 변경해야 하고 어떤 사정으로 오브젝트가 싱글턴일 필요가 없어졌을 때의 비용이 커지는 단점이 있다.

또한, 마찬가지로 싱글턴처럼 오브젝트가 HTTP의 Session인 동안만 있으며 된다거나 Request일 때만 있으면 되는, 오래 살아남으면 곤란한 오브젝트의 생명 주기를 만들어내는 것도 어렵지만, 스프링은 이런 생명주기도 관리해 준다.



##### 부품화의 문제

---

웹 애플리케이션을 구축하는 오브젝트 사이의 의존 관계는 인터페이스를 매개로 해서 구현에 의존하지 않음으로써 오브젝트 사이를 약한 결합으로 유지할 수 있다.

또한, 그렇게 함으로서 오브젝트를 쉽게 확장, 변경하고 개발 효율을 올리며, 시스템을 고품질로 유지할 수 있다.



스프링과 같은 프레임워크를 이용하지 않고 이러한 인터페이스 의존/구현 비의존을 실현하려면 고도의 기술이 필요하다.

예를 들어, 단순히 인터페이스를 이용하는 것만으로는 구현 비의존을 실현할 수 없다.



그래서 보통은 팩토리 메서드등을 도입해서 구현 비의존을 실현한다.



하지만 현실에서는 의존과  비의존을 만들어가는 것 자체를 모르거나 혹은 비용이 많이 발생한다고 여기는 경우가 많다.

그러면 결국 인터페이스에 의존하고 구현에 의존하지 않는 설계/구현이 이루어지지 않고, 개발 효율과 변경/확장의 용의성, 테스트에 의한 품질 유지를 달성할 수 없다.



##### 문제 해결은 스프링에게

---

스프링을 이용하지 않았을 때 일어날 수 있는 웹 애플리케이션의 3가지 문제점은 다음과 같다.

- 오브젝트 생명 주기 문제
- 부품화 문제
- 기술 은닉과 부적절한 기술 은닉 문제



이 문제들은 스프링이 다음과 같이 해결해 줄 수 있다.

- 오브젝트의 생명 주기 문제는 DI 컨테이너로 해결
- 부품화 문제는 DI 컨테이너로 해결
- 기술 은닉과 부적절한 기술 은닉 문제는 AOP로 해결



#### 스프링의 개요

---



##### 스프링이란?

---

스프링은 Java/Java EE용 프레임워크이다.

DIxAOP 컨테이너를 중심으로 MVC 프레임워크, JDBC를 추상화한 프레임워크, 기존 프레임워크와 통합 기능 등을 개발자에게 제공하는 애플리케이션 아키텍처의 기반이 되는 것이다.



##### 프레젠테이션 층

---



###### 스프링 MVC

---

프레젠테이션 층에서는 스프링 MVC와 스프링 웹 플로를 이용할 수 있다.

이것은 웹 애플리케이션의 프레젠테이션 층에서 잘 사용하는 MVC 프레임워크에 해당한다.



###### 스프링 시큐리티

---

정확하게는 프레젠테이션 층, 비즈니스 층, 데이터 액세스 층 전ㅊ체에서 사용할 수 있지만, 프레젠테이션 층의 화면별 액세스 제어에 많이 사용한다.



스프링 시큐리티는 인증/인가 기능을 제공하며, 베이직 인증이나 OAuth의 표준에 따라가는 인증 서비스를 사용할 수 있다.



##### 비즈니스 로직 층

---



###### 스프링 DIxAOP 컨테이너

---

DIxAOP 컨테이너는 스프링을 특징짓는 기능이다.

DI는 오브젝트를 생성하고 오브젝트끼리의 관계를 생성해 소프트웨어의 부품화 및 설계를 가능하게 한다.

DI를 이용하면 인터페이스 기반의 컴포넌트를 쉽게 구현할 수 있다.



DIxAOP 컨테이너에는 물론 AOP 기능도 있다.

AOP를 이용하면 오브젝트 책임 외의 로직을 소스코드에 명시적으로 기술하지 않고 나중에 추가할 수 있다.

소스코드에는 할당된 책임 외의 처리가 필요 없어지고  개발자는 비즈니스 로직에 집중할 수 있어서 코드가 한결 간결해지고 보기에도 쉬워진다.



또한 AOP에 의해 책임 이외의 로직이 없어지면 DI를 이용한 컴포넌트화를 더 추진할 수 있고 단위 테스트나 팀 개발이 쉬워져 시스템 개발 비용을 크게 절감할 수 있다.



###### 스프링 캐시

---

스프링 캐시는 이름처럼 데이터를 캐시해서 RDB와의 처리를 줄임으로써 퍼포먼스를 향상시키는 역활을 한다.



##### 데이터 액세스 층

---



###### 스프링 JDBC

---

스프링은 JDBC를 추상화하는 프레임워크인 스프링 JDBC를 제공하고 있다.



스프링 JDBC는 SQL 문을 이용하는 형태의 데이터 액세스 프레임워크이다.

스프링 JDB의 이용법은 'SELECT 문'과 'SELECT한 결과와 엔티티 클래스의 매핑'을 기술하기만 하면 되므로, SQL 문에 익숙한 개발자라면 간단히 사용할 수 있다.



###### 스프링 데이터

---

RDB와 NoSQL 등의 다른 데이터 스토어에 액세스의 통일화와 단순화를 목적으로 한 프로덕트이다.



###### 스프링 ORM 인티그레이션 기능

---

스프링이 제공하는 ORM 인티그레이션 기능을 이용하면 하이버네이트 등을 간단히 이용할 수 있는 것도 스프링의 장점 중 하나이다.

스프링의 ORM 인티그레이션 기능을 이용하면 각각의 프레임워크를 단독적으로 이용하는 것보다 간단하게 서비스를 만들 수 있다.



##### 스프링 배치

---

실제 시스템 개발에는 배치 처리도 필요하다.

배치 처리는 대량의 데이터의 일괄 처리와 복수 처리, 병행 처리의 실행을 반드시 고려해야 한다.



##### 스프링 부트

---

스프링 부트는 소프트웨어 개발을 위한 기반 프레임워크라고 말할 수 있다.

